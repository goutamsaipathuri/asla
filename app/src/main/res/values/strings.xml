<resources>
    <string name="app_name">ASLA</string>
    <string name="tutorial">Tutorial</string>
    <string name="description">description</string>
    <string name="articles">Articles</string>
    <string name="faq">F.A.Q</string>
    <string name="quiz">Quiz</string>
    <string name="beginner">Beginner</string>
    <string name="intermediate">Intermediate</string>
    <string name="advanced">Advanced</string>
    <string name="general">General</string>g
    <string name="specific">Project specific</string>
    <string name="easy">Easy</string>
    <string name="medium">Medium</string>
    <string name="hard">Hard</string>
    <string name="contact_us">Contact us</string>
    <string name="help">Help</string>
    <string name="next">NEXT</string>
    <string name="skip">SKIP</string>
    <string name="got_it">GOT IT</string>

    <string name="_111_t">What is AUTOSAR?</string>
    <string name="_112_t">Why AUTOSAR?</string>
    <string name="_113_t">Who is AUTOSAR?</string>
    <string name="_114_t">Objectives of AUTOSAR</string>
    <string name="_115_t">Key focus of AUTOSAR</string>
    <string name="_116_t">AUTOSAR Roadmap</string>
    <string name="_117_t">Reach and Access AUTOSAR</string>
    <string name="_121_t">Layered Software Architecture</string>
    <string name="_122_t">Methodology</string>
    <string name="_123_t">Configuration Classes</string>
    <string name="_124_t">Conformance Classes</string>
    <string name="_211_t">Brief on Diagnostic modules</string>
    <string name="_212_t">DCM module</string>
    <string name="_213_t">DEM module</string>
    <string name="_214_t">Interaction between DCM, DEM and Application</string>
    <string name="_215_t">DET module</string>
    <string name="_216_t">FIM module</string>
    <string name="_221_t">Mode managers in AUTOSAR</string>
    <string name="_222_t">EcuM module</string>
    <string name="_223_t">WdgM module</string>
    <string name="_224_t">ComM module</string>
    <string name="_231_t">What are CDDs</string>
    <string name="_232_t">Interaction with CDDs</string>
    <string name="_233_t">What can be designed as CDDs?</string>
    <string name="_234_t">CDD as a Ser vice SW-C</string>
    <string name="_311_t">Introduction</string>
    <string name="_3120_t">Sub-Layers</string>
    <string name="_3121_t">Services Layer</string>
    <string name="_3122_t">ECU Abstraction Layer</string>
    <string name="_3123_t">Complex Device Drivers (CDD)</string>
    <string name="_3124_t">Micro Controller Abstraction Layer (MCAL)</string>
    <string name="_321_t">COM Stack basics</string>
    <string name="_322_t">COM Module</string>
    <string name="_323_t">PduR Module</string>
    <string name="_324_t">IPDU-M Module</string>
    <string name="_3250_t">FR/ CAN/ LIN Stack</string>
    <string name="_3251_t">Basics</string>
    <string name="_3252_t">Hardware Configuration</string>
    <string name="_411_t">Memory Stack basics</string>
    <string name="_412_t">NVRAM Manager Module</string>
    <string name="_413_t">NVRAM Manager as a Service SW-C</string>
    <string name="_414_t">MemIf module</string>
    <string name="_415_t">Flash/ Eeprom Stack</string>
    <string name="_421_t">Introduction</string>
    <string name="_4220_t">Features of OS</string>
    <string name="_4221_t">Fundamentals of AUTOSAR OS</string>
    <string name="_4222_t">Extensions to and restrictions on OSEK OS</string>
    <string name="_4223_t">OS Tasks</string>
    <string name="_4224_t">OS counters</string>
    <string name="_4225_t">OS Alarms</string>
    <string name="_4226_t">OS Events</string>
    <string name="_4227_t">OS Scheduler and Schedule tables</string>
    <string name="_4228_t">Schedule table Synchronization</string>
    <string name="_4229_t">ISRs and types</string>
    <string name="_42210_t">OS Resources</string>
    <string name="_42211_t">OS Protection</string>
    <string name="_42212_t">OS Hooks</string>
    <string name="_42213_t">Services to SchM</string>
    <string name="_423_t">OS Scalability classes</string>
    <string name="_431_t">Basics of Measurement and Calibration</string>
    <string name="_432_t">XCP module</string>
    <string name="_433_t">Calibration with FR/ CAN</string>
    <string name="_434_t">Interaction of XCP module</string>
    <string name="_511_t">Introduction</string>
    <string name="_512_t">RTE Concepts</string>
    <string name="_513_t">Calibration</string>

    <string name="_111_m1">
        AUTOSAR - AUTomotive Open System ARchitecture
        \n\nConsortium found in 2002 by auto manufacturers later joined by suppliers and silicon chip providers
        \n\nInitiative supported by auto industry to develop a de-facto open standard for automotive E/ E architectures
        \n\nFocuses to specify standard architecture for system software
        \n\nSoftware development based on function based approach
        \n\nAims to improve performance, safety and environmental electronic systems
    </string>
    <string name="_112_m2">
        To have a common requirements/ understanding between auto stake holders
        \n\nCreate a standard core for industry on basic functions where innovative functions are built on top of it
        \n\nHW and SW are widely independent. With parallel developments, reduces the development time and costs
        \n\nRe-use of software increases at OEMs and suppliers. Improve the quality and efficiency
        \n\nFaster development of auto software thru commercial design tools
        \n\nSoftware integration from multiple vendors at ease
    </string>
    <string name="_113_m1">
        AUTOSAR consortium consists of three members identified based on their initiatives
\n\nThe members will be given appropriate rights and allocated to the various duties
\n\nMembers of AUTOSAR
\n  - Core partners
\n  - Premium members
\n  - Associate members
\n\nSupport members of AUTOSAR
\n  - Development members
\n  - Attendees
    </string>
    <string name="_121_m5">
        Follows ‘Component’ style
\n\nInteraction between SW-Cs and to BSW thru RTE
\n\nFollows the methodology to interact between SW-Cs
\n\nSW-Cs shall be different types identified as on need basis
\n\nEach SW-C has a part of functionality of an application
    </string>
    <string name="_121_m6">
Acts as middle layer to abstract SW-Cs from BSW
\n\nMakes application layer independent of BSW layer
\n\nImplements communication mechanisms to interact within SW-Cs and between SW-C and BSW
\n\nInternal behavior of all SW-Cs in ECU will be configured and implemented here
    </string>
    <string name="_121_m7">
BSW has all the modules needed for application
\n\nAUTOSAR defines the specifications for the all the modules and their integration
\n\nHas modules to interact directly with hardware
\n\nHas OS for scheduling purposes
    </string>
    <string name="_121_m8">
The communication happens thru ports those implements interfaces as per communication mechanism
\n\nEach SW-C will have ports to interact
\n\nCommunication thru RTE
\n\nThe communication in BSW is abstracted to the SW-Cs
    </string>
    <string name="_123_m1">
        AUTOSAR supports 3 configuration classes
\n\nPre-Compile time
\n  - The software controlled by configuration at pre-compile time
\n  - Need to re-make the software upon changes
\n  - Support only parameters of Pre-Compile time
\n\nLink-time
\n  - The constant configuration data can be supplied as object code at link time (Warranty reasons, IP protection etc.)
\n  - Need to re-link the software upon changes
\n  - Support the parameters of Pre-Compile time and Link time
\n\nPost-build time
\n  - The constant configuration data can be supplied/ loaded at any time at known fixed entry point
\n  - Load new configuration data at any time
\n  - Support the parameters of all above
    </string>
    <string name="_124_m1">
        Has 3 Conformance Classes
\n  - ICC1
\n  - ICC2
\n  - ICC3
        \n\nThe classes are based on
\n  - AUTOSAR compliancy
\n  - Standardizationsacross different layers
\n  - Standardizationsacross sub-layers, clusters, stacks and modules etc.
    </string>

    <string name="_211_m1">Supports fault handling and reporting
\n\nThe possible errors/ failures AUTOSAR addresses are
\n  - Hardware errors
\n  - System errors
\n  - Software errors
\n\nAddressing the errors
\n  - Development stages
\n    - Reported to DET module
\n    - Feature can be switched OFF after development stage
\n    - Optional feature can be switched ON/ OFF
\n  - Production stages
\n    - Reported to DEM module
\n    - Feature shall be always ON to store and retrieve the permanent errors
\n    - Errors can be retrieved thru external tools
</string>
    <string name="_212_m1">Provides services for Diagnostics
\n\nInteracts over LIN/ CAN/ FR with external tools
\n\nSupports LIN/ CAN/ FR communication
\n\nInteracts with BSW directly, SWCs thru RTE to set/ get the data
\n\nInteracts with fault memory
\n\nHandles variety of diagnostic protocols</string>
    <string name="_212_m4">DCM functionalities
\n\nHandles diagnostic communication
\n\nInteracts with application
\n\nInteracts with ComM to handle communication states
\n\nHandles tester presence service
\n\nSecurity level handling
\n\nManaging diagnostics sessions
\n\nHandling various diagnostic protocols
\n\nService response handling
\n\nRealized as Ser vice SW-C</string>
    <string name="_213_m1">Provides services to
\n  - Process and access fault data
\n  - Snapshots fault data at occurrence
\n  - Accessto freeze frame data
\n\nProvide fault data to DCM
\n\nAccesses the NV memories to handle fault data
\n\nEnable/ Disable fault logging
\n\nFault reactions handled by FIM module
\n\nRealized as Service SW-C</string>
    <string name="_213_m2">More features of DEM
\n\nEvent combination (Optional feature)
\n\nPre-storage of Freeze frame data
\n\nSupports extended data records
\n\nDEM operation cycles
\n\nNV memory access
\n\nDe-bouncing algorithms for events
\n  - Count er/ Time/ Frequency based
\n    - DTC fault detection counter
\n\nRealized as Ser vice SW-C</string>
    <string name="_215_m1">BSW report the errors detected at development stages
\n\nThe report collects
\n  - Module occurred
\n  - Function occurred
\n  - Error classification
\n\nThe functionality is implementation specific
\n\nPossible use cases are
\n  - Count ing the errors
\n  - Log calls
\n\nRealized as Ser vice SW-C
</string>
    <string name="_216_m1">Control the fault reaction functionalities
\n\nFunctionalities check the inhibit conditions before executing
\n\nEvent status information acts as inhibit conditions
\n\nExample
\n  – A sensor can have inhibit conditions. Upon failure, the functionality checks the inhibit condition and stops executing
\n\nSupports summarized event
\n\nRealized as Service SW-C
</string>
    <string name="_221_m1">ECU has states between power-up to shutdown
\n\nStates on ECU, communication, network levels etc.
\n\nFor smooth operation, these states has to be transitioned
\n\nStates has to synchronize
\n\nIn AUTOSAR we have
\n  - ECU states: Managed by EcuM
\n  - Wdg states: Managed by WdgM
\n  - Communication states: Managed by ComM
\n\nApplication shall have their states and logic
</string>
    <string name="_222_m1">First module to be initialized in AUTOSAR software
\n\nInitializes the ECU state machine
\n\nInitializes all the modules
\n\nApplication need to request RUN/ SHUTDOWN states
\n\nHandles sleep and wake-up functionalities
\n\nPerforms wake-up validation
\n\nHandles initialization and shutdown procedure thru state machine
\n\nHandles various shutdown targets
</string>
    <string name="_222_m2">EcuM States
\n\nEcuM initialization starts the state machine
\n  - STARTUP states
\n    - STARTUP I
\n      - Start up state before OS started
\n      - Modules independent of OS are initialized
\n      - Fundamental needs for ECU (Mcu, Det etc.) are initialized
\n    - STARTUP II
\n      - Start up state after OS started
\n      - Modules dependant on OSare initialized
\n      - Modules with schedulable functions shall be initialized
</string>
    <string name="_222_m3">After STARTUP states, the state machine moves to
\n  - RUN states
\n    - RUN
\n      - Execution of application tasks
\n      - User has to request RUN state
\n      - If valid RUN request, ECU stays in RUN state
\n      - If no RUN request with in predefined t ime, moves to POSTRUN state
\n      - State shall be left if user releases the request
\n    - POSTRUN
\n      - If user has any post activities, need to request POSTRUN before releasing RUN
\n      - If RUN request, goes back to RUN state
\n      - State shall be left if user releases the request
\n      - If released, moves to SHUTDOWN state</string>
    <string name="_222_m4">After RUN states, the state machine moves to
\n  - SHUTDOWN states
\n    - PREP SHUTDOWN
\n      - Application is de-initialized
\n      - No network
\n      - If shutdown target is SLEEP, goes to GOSLEEP state else GOOFF I
\n    - GO SLEEP
\n      - Settings to made to go the sleep phase
\n      - If valid wakeup, clear and enable the interrupts and moves to WAKEUP state
\n      - Save NV data
\n      - Enable wake-up sources
\n      - Move Wdg state to SLEEP
\n      - For data safety, the RAM integrity algorithms shall be created
\n    - GOOFF I
\n      - De-initialize all modules dependant on OS
\n      - Set Wdg mode to shutdown
\n      - Save NV data
\n      - Set RESET as shutdown target, if any pending wakeup events found
\n      - Shut down OS
\n    - GOOFF II
\n      - If Shut down target is RESET, Mcu performs RESET else SHUTDOWN
</string>
    <string name="_222_m5">SLEEP state
\n  - SLEEP state achieved from GOSLEEP if there are no wake up events
\n  - No code is executed in this state as micro is halted
\n  - If any wakeup found on the way to SLEEP, moves to WAKEUP state
\n  - Wakeup sources should be enabled in SLEEP state
\n  - Upon a valid wakeup, WAKEUP state shall be achieved</string>
    <string name="_222_m6">WAKEUP states
\n  - WAKEUP I
\n    - Restore MCU and Wdg states to normal
\n    - Re-initialize the wakeup source drivers
\n    - Actual wake source should set an wakeup event
\n    - Disable wakeup sources
\n    - Unlock the scheduler
\n  - WAKEUP VALIDATION
\n    - Validate the pending wakeup events
\n    - Eliminate false wakeups
\n  - WAKEUP REACTION
\n    - Action to be taken on successful wakeup validation
\n    - Move to RUN, Shut down state etc..are possibilities
\n  - WAKEUP II
\n    - Initialize the diagnostics
\n    - Indicate the modes to RTE</string>
    <string name="_222_m7">EcuM as a Service SW-C
\n\nEcuM provides predefined ports to connect to application
\n  - Release/ Request RUN state
\n  - Release/ Request POST RUN state
\n  - Select / get shutdown target
\n  - Select / get application modes
</string>
    <string name="_222_m8">Configuration
\n\nEcuM SWC description can be arrived with
\n  - Port interfaces
\n    - S/R interfaces for getting modes
\n    - C/S interfaces for predefined ports
\n  - Modes
\n    - Mode ports and interfaces
\n  - Data types
\n    - Mode Declaration Gr oup with all ECU modes
\n    - All types of EcuM
\n  - Runnables
\n    - All EcuM services
\n    - EcuM services as server operations
</string>
    <string name="_223_m1">To supervise the reliability of software execution
\n\nProvides alive-supervision of application
\n\nTrigger the hardware Wdg
\n\nCan supervise multiple entities
\n\nTakes the decision on global supervision
\n\nEach SE has to provide live indications to WdgM
\n\nEcuM sync Wdg to ECU states
</string>
    <string name="_223_m2">Wdg Modes
\n\nSupports different modes
\n\nEach mode is defined by
\n  - Set of active SEs and their alive supervision parameters
\n  - Set of Wdgs to be tr iggered and their triggering parameters
\n\nSource of activation for cyclic activities of WdgM
\n\nConfigur able number of modes
\n\nDifferent modes used for phases of ECU
\n\nUpon errors, entry for DEM is available</string>
    <string name="_224_m1">Contr ols BSW related to communication
\n\nProcesses bus communication requests
\n\nAbstract the communication hardware and software
\n\nEnable/ Disable the communication signals/ messages
\n\nHighest state results upon multiple requests from same user
\n\nCover s FR, CAN and LIN buses
\n\nManages Network and state managers
\n\nManages bus errors
\n\nRealized as Ser vice SWC</string>
    <string name="_224_m2">Bus error management
\n\nNetwork start indication for specific bus channel
\n\nSwitch to FULL COM on this indication
</string>
    <string name="_231_m1">CDD – Complex Device Drivers
\n\nThe devices with need of complex processing time
\n\nStandard/ Non-standard from AUTOSAR
\n\nNo need to follow any standard within CDDs but AUTOSAR way to outside software
\n\nThe scaled AUTOSAR driver can also be a CDD
\n\nA highly compact IP design/ algorithm software can fit as CDD
\n\nNon-AUTOSAR communication drivers
</string>
    <string name="_232_m1">Interaction with in CDD is implementation specific
\n\nInteraction from CDD to application is thru RTE
\n\nNo abstraction layers between RTE, CDD and Hardware
\n\nPossible to interact with BSW modules
\n\nShall use OS for its schedulable entities
\n\nEcuM shall initialize
\n\nShall use OS for interrupts
\n\nShall use SPI for external communication
\n\nRealized as Ser vice SW-C
</string>
    <string name="_233_m1">Anything not available in AUTOSAR standards
\n\nAnything complex – Complex Sensors and Actuators
\n\nElectrical interfacing – Motor controls and actuators
\n\nComplex algorithm processing – DSP processors for Camer a/ Radar etc.
\n\nIP ASICs
\n\nProtocols - I2C, IP protocols etc.
\n\nCr ypto hardware services
\n\nDEShardware services</string>
    <string name="_234_m1">
        Realized as Ser vice SWC
\n\nSWC description can be made with below and imported in application
\n  - CDD data types
\n  - CDD APIs
\n  - CDD schedulable functions
\n  - CDD server operations
\n  - PDAVs for CDD APIs
\n  - Mode declaration groups etc.
    </string>

    <string name="_311_m1">Executes the functional part of application needs
\n\nBSW offers
\n  - Communication services
\n  - Diagnosticsservices
\n  - Calibration services
\n  - Memory services
\n  - Micro Controller services
\n  - OSser vices
\n  - Mode Management services
\n  - Complex Device Drivers
\n\nAccess to hardware
\n\nAbstract application from hardware for more portability
\n\nHardware independent BSW parts can be re-used completely
</string>
    <string name="_3120_m1">BSW has below main sub layers
\n  - Service layer
\n  - ECU Abstraction layer
\n  - Complex Device Drivers (CDD)
\n  - Micro Controller Abstraction Layer (MCAL)
</string>
    <string name="_3121_m1">Offer s basic services required for BSW and applications
\n\nServices include
\n  - System services
\n  - Memory services
\n  - Communication services</string>
    <string name="_3122_m1">Abstracts ECU hardware
\n\nAbstracts MCAL from Ser vice layer
\n\nInterfaces external devices
\n\nOffer s various abstraction services
\n  - Onboar d device abstraction
\n  - Memory hardware abstraction
\n  - Communication hardware abstraction
\n  - IO hardware abstraction
</string>
    <string name="_3123_m1">Enables to integrate special purpose functionality not specified in AUTOSAR
\n\nSpecific devices with high timing constraints
\n\nEnables a way for migration
\n\nCDDs hardware access is abstraction free
\n\nCDDs interact directly to RTE to less the latency</string>
    <string name="_3124_m1">Lowest layer access to hardware
\n\nAccess to micro controller peripherals, on-board modules
\n  - Micro controller drivers
\n  - Memory drivers
\n  - Communication drivers
\n  - IO drivers
</string>
    <string name="_321_m1">For Vehicle network communication, FR/ CAN/ LIN stacks available in AUTOSAR
\n\nA stack of modules i.e. comm driver, abstraction module, Tp operation, routing, unpacking/ packing of signals etc. makes a complete COM Stack
\n\nCOM managers (states, NM etc.), Calibration are also included to enhance
</string>
    <string name="_321_m2">A physical representation of a high numerical level data
\n\nSignal types
        \n\nHave a start position and initial value and updated to PDU directly
\n\nGroup Signal
\n  - A signal depending on other signals
\n  - Data has to be updated in shadow fir st
\n\nSignal group
\n  - A set of group signals packed in a complex signal
\n  -         May have 0…N group signals inside
\n  - Data has to be updated to PDU from Shadow
    </string>
    <string name="_321_m3">PDU (Protocol Data Unit)
\n  – A data unit packed with set of signals/ group signals
\n  - PDU can’t have both signals and group signals at a time
        \n\nPDU Group
\n  - A group of zero or more PDUs or PDU groups
\n  - A set of PDUs/ PDU Groups transmission/
     reception can be controlled by specific PDU Group start/ stop
\n  - Limited to 32 in an ECU
</string>
    <string name="_321_m4">All the PDUs info is available in EcuC
\n\nModules access EcuC for PDU properties
</string>
    <string name="_322_m1">Top BSW module communicating to RTE
\n\nProvides services to application thru RTE and rest of BSW COM Stack
\n\nFunctionalities of COM module includes
\n  - Signal and Message access
\n  - Both Signal and Message access and Gat eways by COM
\n  - Packing and un-packing of signals to/ from messages
\n  - Deadline monitoring
\n  - Filter based reception
\n  - EndianNess handling
\n  - Communication modes
\n  - Signal transfer modes
\n  - PDU Transmission modes
\n  - Signal indication modes
\n  - Immediate
\n  - Deferred
\n  - Communication transmission control (start/ stop of PDU groups)</string>
    <string name="_322_m3">Applied at reception
\n\nRemoves unwanted data and their processing
        \n\nSupports signed types also. No support for complex types
\n\nAlso used for Transmission Mode Selection (TMS)
</string>
    <string name="_322_m5">COM supports 2 modes for communication
\n  - Modes for Signals (Transfer properties)
\n  - TRIGGERED
\n  - PENDING
\n  - Modes for PDUs (Transmission modes)
\n  - PERIODIC
\n  - DIRECT/ N-TIMES
\n  - MIXED
\n  - NONE</string>
    <string name="_322_m6">
        Suppor ts for both interrupt and polling methods
\n\n2 modes
\n  - IMMEDIATE
\n  - DEFERRED
    </string>
    <string name="_322_m7">Communication can be enabled/ disabled for specific PDUs
\n\nPDUs can be logically grouped as groups and then controlled
\n\nTransmission control by state managers thru COM
\n\n2 levels of IPDU-Group depth allowed
</string>
    <string name="_323_m1">PduR Module placed between COM and FR/ CAN/ LIN Stack
\n\nProvides interfaces to communication related modules
\n\nFunctionalities of PduR module are
\n\nRouting functionality
\n  - Gateway functionality
\n  - Minimum Routing capability
\n  - Multi Cast operation
\n  - Zero Cost operation</string>
    <string name="_323_m3">Only predefined Pre-Compile and Link-time configurations possible
\n\nNo routing tables
\n\nOptional feature
</string>
    <string name="_323_m4">MultiCast Routing
\n\nMultiCast Gatew ay Routing</string>
    <string name="_323_m5">Eliminate PduR module actual functionality
\n\nPduR hand shakes between upper and lower layers with zero latency
\n\nPduR just maps the interfaces of source and destination modules
</string>
    <string name="_324_m1">Enables the multiplexing of PDUs
\n\nPossible only with static configuration
\n\nMultiplexed PDU will have Static and Dynamic parts
\n\nStatic part will have layout as configured
\n\nThe dynamic part may be multiplexed as configured and sent using same PDU Id</string>
    <string name="_3250_m1">Deals with FR/ CAN/ LIN services
\n\nA stack includes
\n  - &lt;X&gt;Driver
\n  - &lt;X&gt;Internal Driver
\n  - &lt;X&gt;External Driver interfaced with SPI
\n  - &lt;X&gt;If module
\n  - LIN Tp is integrated with LIN If
\n  - &lt;X&gt;Tp module
\n  - No separate LIN Tp
\n  - &lt;X&gt;Sm module
\n  - &lt;X&gt;Nm module
\n\nOver view of these modules are in next slides</string>
    <string name="_3251_m3">Tp Operation
\n\nSegments large data into PDU size
\n\nRe-assemble segmented PDUs into large chunk
\n\nMaintains a protocol with flow control
\n\nTransmit cancellation
\n\nUses Timer resources

\n\nExample:
\nPduR trying to send 50bytes
</string>
    <string name="_3251_m4">State Management
\n\nHandles communication states
\n\nAligns the transceiver modes based on application needs
\n\nControl the PDU groups
\n\nAnswers the bus errors (bus-off) by moving into safe states
\n\nBased on requested communication mode, the transmission/ reception can be stopped and started
\n\nHandles timeout for Deadline monitoring

\n\n\n\nAbstraction modules
\n\nAbstract CAN hardware
\n\nControl the CAN driver and transceiver
\n\nControl the external CAN hardware interface thru SPI
\n\nHandles transmit confirmations
\n\nHandles reception, bus-off and wake-up notifications
\n\nConfigure software mailboxes with BASIC/ FULL fashion
\n\nMultiple CAN driver support
</string>
    <string name="_3251_m5">Network Management
\n\nCo-ordinate between network states
\n\nRealized thru voting mechanism. Consolidation of ECUs votes on periodic basis results in taking the decision
\n\nAble to detect all present nodes and nodes which are ready to sleep
\n\nSupports bus-sleep and wake-up mechanisms
\n\nPartial networking not supported
\n\nHas the below modes
\n  - Network mode
\n  - Prepare Bus-Sleep mode
\n  - Bus-Sleep mode</string>
    <string name="_3252_m1">The respective HW (FR/ CAN/ LIN) has to be configured with
\n  - Mailboxes
\n  - HW filters
\n  - ISR/ Polling based communication
\n  - Transceiver configuration
        \n\n\nMailboxes configuration
\n\nCAN controller has predefined HW mailboxes
\n\nEach mailbox associated with HW filter to pass through
\n\n&lt;X&gt;If module can have SW mailboxes for the respective HW mailboxes
\n\nHW mailboxes can be assigned in BASIC/ FULL CAN fashion
</string>
    <string name="_3252_m2">HW filters
\n\n        Each HW mailbox associated with HW filter
\n\nHW filter helps to send/ receive only filtered message with matching ID in FULL CAN
\n\nIn BASIC CAN, a filter can allow messages with the range of IDs passed thru the filter
       \n\n\n ISR/Polling based message access
\n\nWith ISRs, the reception of data in HW mailbox is tr iggered with ISR
\n\nIf indications/ notifications are configured, they will be tr iggered
\n\nBus-Off and Wake-up processing can by done by ISR tr iggering
\n\nWith Polling, CanIf has to poll for reception
\n\nThe schedulable functions of CAN has to take care of the data and notifications
</string>
    <string name="_3252_m3">Transceiver configuration
\n\nConver ts bus logical signals to physical signals
\n\nAble to detect bus errors
\n\nSleep, Wake-up etc. modes shall be configured
\n\nIO pins used for transceiver shall be configurable
\n\nAlways powered-on to detect the wake-ups
</string>

    


    <string name="a1">
        The interoperability of solutions requires a high quality standard. AUTOSAR has defined a process to ensure such high quality when changes are introduced in a revision or when new features are introduced in new minor or major releases.
        \n\n
        AUTOSAR is also continuously monitoring the interoperability of AUTOSAR tool chain solutions and provide acceptance tests for the Classic Platform which enable an early assessment of suppliers’ basic software solutions in a development process.
        \n\n
        AUTOSAR’s Adaptive Platform is designed for interoperability with other software platforms. By using dynamic service oriented communication patterns, applications can easily exchange information with for example infotainment systems.
    </string>
    <string name="a2">
        New use-cases require the development of the Adaptive Platform.
        \n
        Highly automated driving where the driver temporarily and/or partially passes responsibility for driving to the vehicle. This requires for instance communication with traffic lights, the use of high-performance micro-controllers and computing.
        \n\n
        Car-2-X applications require interaction to vehicles and off-board systems. That means the system has to provide secure on-board communication, support of cross domain computing platforms, smartphone integration, integration of non-AUTOSAR systems, and so on.
        \n\n
        Cloud based services will require dedicated means for security such as secure cloud interaction and emergency vehicle preemption. They will enable remote and distributed services, for instance remote diagnostics, in-field flashing, repair and exchange handling.
    </string>
    <string name="a3">
        The Classic Platform is the first choice for deeply embedded ECUs with high demands regarding safety and deterministic execution. It targets small and medium sized microcontrollers.
        \n\n
        The Adaptive Platform supports adaptive deployment of applications and interaction with Classic Platform and non-AUTOSAR systems. It targets high performance microcontrollers.
    </string>
    <string name="a4">
        Updates and improvements of the standard will be introduced by future versions of AUTOSAR. Corrections are handled by a change management process and are provided as revisions of the existing releases. New features are matured in concepts which are introduced only in new releases. New minor releases accept only backward compatible features whereas major releases could introduce non backward compatible features. The AUTOSAR versions are numbered according to this scheme: andlt;major releaseandgt;.andlt;minor releaseandgt;.andlt;revisionandgt;.
        \n\n
        AUTOSAR’s standard Adaptive Platform makes use of agile development methods. That means functions and updates are developed in sprints. There is a regular release cycle to introduce those functions and updates into the market.
    </string>
    <string name="a5">
        Yes, AUTOSAR provides application interfaces for Body, Chassis, Pedestrian and Occupant Safety, and Powertrain applications.
    </string>
    <string name="a6">
        One of the main requirements of AUTOSAR is to assure the interoperability with legacy software. This will enable the re-use of existing, non-AUTOSAR compliant software, e.g. drivers. The most obvious way to reach this integration is using a Complex Driver as a wrapper around the non-AUTOSAR compliant software.
    </string>
    <string name="a7">
        The acceptance of AUTOSAR will depend heavily on processing and memory requirements. The modular architecture of AUTOSAR provides a scalable solution where users or implementers can discard modules or configure out features of the basic software in order to limit the memory and performance impacts in micro controllers.
    </string>
    <string name="a8">
        Using and implementing existing standards is given the highest priority.
        \n\n
        This has been the case since the beginning of the project. For example AUTOSAR’s operating system and communication stack were based on OSEK, and the AUTOSAR System Template was based on ASAM. Furthermore AUTOSAR introduces support for new standard when there is a market need for the automotive industry.
        \n\n
        As AUTOSAR members also participate to the elaboration of other standard, it has been possible to provide, with AUTOSAR, and standardized software solution to implement other standard as soon as they are published. For instance functional safety mechanisms were added to support ISO 26262, and the partial networking or Can FD concepts were introduced to support new versions of ISO 11898.
    </string>

</resources>
